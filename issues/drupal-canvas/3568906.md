# #3568906: Handle upgrading and rendering not yet upgraded component instances of components with newly removed props or slots

- **Project:** Drupal Canvas
- **Type:** Normal feature request
- **Version:** 1.x-dev
- **Status:** Fixed
- **Diff:** [6107979](https://git.drupalcode.org/project/canvas/-/commit/6107979db5fb0d01ab4cfe59341c11fda4dd4a77) · +74/-29 prod · +370/-25 test · 8 files
- **Discussion:** [#3568906](https://www.drupal.org/node/3568906) · 5 contributors · 37 comments

## Summary

Canvas now automatically handles component evolution when developers remove props or slots from components. When a site builder edits a page containing an old component instance, the system removes data for props and slots that no longer exist. This prevents orphaned data from accumulating and ensures pages remain valid even as components change over time. If a developer removes a prop or slot and then adds it back before the page is edited, the old data is preserved and continues to work.

## Impact

No upgrade or configuration changes required.

## Technical details

The `GeneratedFieldExplicitInputUxComponentInstanceUpdater` class now handles removed props and slots as safe upgrade operations. Previously, removing props or slots was considered unsafe and blocked automatic upgrades. Now when `canUpdate()` evaluates a component instance, it no longer checks for removed props or slots. The `update()` method uses `array_diff_key()` to identify removed props and deletes their values from the component instance inputs. For removed slots, it filters the `ComponentTreeItemList` to remove child component instances whose slot name matches a removed slot and whose parent UUID matches the component being upgraded.

The `ComponentSourceManager::updateComponentInstances()` method now returns a boolean indicating whether any instances were modified. `ApiLayoutController::buildRegion()` uses this return value to determine whether to create an auto-save entity. When the controller detects modifications during GET requests, it saves the updated component tree as an auto-save so subsequent PATCH requests work with the cleaned-up tree rather than the published version.

Test coverage includes `ApiLayoutControllerPatchTest::testPatchCleansUpOrphanedChildrenOnComponentEvolution()`, which verifies a two-phase removal scenario: first removing one slot from a component with two slots, then removing the remaining slot. The test confirms that children in removed slots are cleaned up during auto-update and that publishing succeeds after each phase.

## Timeline

- Opened: January 22, 2026
- First commit: February 13, 2026 (22 days later)
- Last commit: February 17, 2026 (3 days later)

## Collaboration

Matt Glaman implemented the core logic for removing orphaned props and slots, including the elegant solution for filtering component trees to remove slot children. Penyaskito provided detailed steps to reproduce edge cases and created follow-up issues to track UX improvements around auto-saves. Effulgentsia wrote a comprehensive issue summary that clearly scoped the problem and guided the implementation. Wim Leers provided thorough code review, raising important questions about data loss and helping refine the approach through multiple iterations. Lauri Eskola confirmed the product direction, balancing simplicity against potential concerns about content loss.

## Lessons learned

- When component schemas evolve, delaying data cleanup until edit-time provides a recovery window. If schema changes are reverted before content is edited, the old data resurfaces automatically without requiring restoration logic. *(via effulgentsia, lauriii, mglaman)*
- When rendering components with schema mismatches, rendering with extraneous data (extra props or slots that no longer exist in the schema) is safer than filtering it out. The component code simply ignores unexpected data, avoiding the need for runtime transformation logic and allowing cleanup to happen explicitly during edit operations. *(via mglaman, penyaskito, effulgentsia)*
- When removing features that contain user data (like component slots or fields), follow established deletion patterns from analogous systems. Just as deleting a folder deletes its contents or removing a database column deletes its data, removing a container should remove its contents rather than attempting to rescue orphaned data into visible UI elements. *(via lauriii)*

---

*This summary is AI-generated and may contain errors. Check the [original issue on Drupal.org](https://www.drupal.org/node/3568906) for the full picture. For more digests, see [Drupal Digests](https://github.com/dbuytaert/drupal-digests/).*
