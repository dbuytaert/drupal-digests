# #3568906: Handle upgrading and rendering not yet upgraded component instances of components with newly removed props or slots

- **Project:** Drupal Canvas
- **Type:** Normal feature request
- **Version:** 1.x-dev
- **Status:** Fixed
- **Diff:** [6107979](https://git.drupalcode.org/project/canvas/-/commit/6107979db5fb0d01ab4cfe59341c11fda4dd4a77) · +74/-29 prod · +370/-25 test · 8 files
- **Discussion:** [#3568906](https://www.drupal.org/node/3568906) · 5 contributors · 36 comments

## Summary

Canvas now automatically upgrades component instances when props or slots are removed from a component definition. When you edit a page that uses an older version of a component, any prop values or slot contents that no longer exist in the current component definition are removed during the upgrade. This prevents data from accumulating in component instances when components evolve. If you temporarily remove and then re-add a prop or slot before editing affected pages, those pages retain their original data and continue working as before.

## Impact

No upgrade or configuration changes required.

## Technical details

The `GeneratedFieldExplicitInputUxComponentInstanceUpdater` now allows automatic upgrades when props or slots are removed from a component. Previously, removing a prop or slot was considered an unsafe change that prevented auto-updates. The `canUpdate()` method no longer blocks updates for removed props or slots. The `update()` method now actively cleans up orphaned data by removing prop values that don't exist in the active version using `array_diff_key()` on inputs, and filtering out child component instances from removed slots using `ComponentTreeItemList::filter()`.

The `ComponentSourceManager::updateComponentInstances()` now returns a boolean indicating whether any modifications occurred. The `ApiLayoutController` uses this to create an auto-save when component trees are modified during GET requests, ensuring that subsequent PATCH requests work with the cleaned-up tree rather than re-loading the published version with orphaned data.

Test coverage includes scenarios where slots are progressively removed (two slots to one, then one to zero) and verifies that orphaned children are cleaned up through GET-triggered auto-updates and survive through PATCH and publish operations. The documentation in `data-model.md` was updated to list removing props and slots as safe changes.

## Timeline

- Opened: January 22, 2026
- First commit: February 13, 2026 (22 days later)
- Last commit: February 17, 2026 (3 days later)

## Collaboration

mglaman implemented the core updater logic and comprehensive test coverage including the multi-phase slot removal scenario. penyaskito provided detailed testing and steps to reproduce edge cases, and identified a related issue with region handling. effulgentsia guided the scope decisions and provided technical review. wim leers conducted thorough security review around data loss concerns, leading to refinements in the auto-save approach. lauriii weighed in on the philosophical approach, advocating for the simpler deletion pattern consistent with Drupal's existing systems like Layout Builder.

## Lessons learned

- When a framework automatically upgrades data structures in response to schema changes, deleting orphaned data immediately can cause unexpected data loss. Defer cleanup until the user explicitly saves the data, providing a grace period where the old data remains available if the schema change is reverted. *(via mglaman, penyaskito, effulgentsia)*
- When rendering components with version mismatches between definitions and instances, passing extra data (unused props or slots) is safe if the component code ignores unknown inputs. This allows deferred upgrades without breaking rendering, and cleanup can happen only when data is explicitly saved. *(via mglaman, penyaskito)*
- When framework data cleanup follows established patterns from analogous systems (like database column drops or content type field removals), simpler deletion semantics are preferable to complex rescue mechanisms. Consistency with user expectations from similar features reduces cognitive load even if individual cases might benefit from recovery options. *(via lauriii)*

---

*This summary is AI-generated and may contain errors. Check the [original issue on Drupal.org](https://www.drupal.org/node/3568906) for the full picture. For more digests, see [Drupal Digests](https://github.com/dbuytaert/drupal-digests/).*
