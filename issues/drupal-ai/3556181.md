# #3556181: Create a form element for selecting providers

- **Project:** Drupal AI
- **Type:** Normal feature request
- **Version:** 2.0.x-dev
- **Status:** Fixed
- **Diff:** [51d88cc](https://git.drupalcode.org/project/ai/-/commit/51d88cc359b3f56ba1d39c26257b4698c20dd318) · +2549/-91 prod · +966/-0 test · 18 files
- **Discussion:** [#3556181](https://www.drupal.org/node/3556181) · 9 contributors · 43 comments

## Summary

The AI module now provides a standardized form element for selecting AI providers and models. Sites and modules can use `ai_provider_configuration` in their forms instead of building custom provider selection UI. This element handles provider/model dropdowns, optional configuration fields, and default provider selection. All AI-related modules can now offer a consistent experience when users choose which AI service to use for different tasks.

## Impact

No upgrade or configuration changes required.

## Technical details

The new `AiProviderConfiguration` form element (`#type => 'ai_provider_configuration'`) standardizes provider and model selection across the AI ecosystem. The element accepts several properties: `#operation_type` (required, such as 'chat' or 'text_to_image'), `#advanced_config` (boolean, shows model configuration fields via AJAX), `#default_provider_allowed` (boolean, adds a "Default" option when a default provider is configured), and `#default_value` (array with provider, model, and config keys).

The element returns a structured array with three keys: `provider` (the provider plugin ID), `model` (the model ID), and `config` (configuration parameters as an associative array). When advanced configuration is enabled, selecting a provider/model triggers an AJAX callback that loads the provider-specific configuration fields based on the provider's schema. The `valueCallback()` method handles both initial form builds and submissions, properly casting configuration values according to their schema types.

The element supports pseudo operation types, which are filtered variants of real operation types. For example, `chat_with_image_vision` is a pseudo operation that filters chat models to only those supporting image vision capabilities. A new `PseudoOperationTypes` utility class centralizes the definition of built-in pseudo operations, replacing duplicated code in `AiSettingsForm`. The element maps pseudo types to their actual operation type when loading schemas and options.

Additional features include `#inline_description` (displays help text between the dropdown and configuration section), `#empty_option` and `#empty_value` (customize the empty option behavior), and automatic handling of default providers (the "Default" option resolves to the configured default provider and clears the config array).

The element integrates with the existing `ai.provider_config` schema for consistent storage. Comprehensive documentation in `ai_provider_configuration_element.md` provides usage examples, migration guides from the older `AiProviderFormHelper` service and simple options list, and complete examples for saving to configuration using `ConfigFormBase`.

Browser tests in `AiProviderConfigurationElementTest` verify AJAX loading, default value handling, form submission value structure, and configuration visibility behavior.

## Upgrade

No upgrade steps are required for existing sites. The new form element is available for modules to adopt in their own forms. Module developers who want to standardize their provider selection UI can replace custom implementations with the new element.

To migrate from the old `AiProviderFormHelper` service pattern:

```php
// Before
$form_helper = \Drupal::service('ai.form_helper');
$form_helper->generateAiProvidersForm(
  $form, $form_state, 'chat', 'prefix',
  AiProviderFormHelper::FORM_CONFIGURATION_FULL,
  0, '', $this->t('AI Provider'), $this->t('Description'), TRUE
);

// After
$form['provider_config'] = [
  '#type' => 'ai_provider_configuration',
  '#title' => $this->t('AI Provider'),
  '#description' => $this->t('Description'),
  '#operation_type' => 'chat',
  '#advanced_config' => TRUE,
  '#default_provider_allowed' => TRUE,
];

// In submit handler
$value = $form_state->getValue('provider_config');
$provider_id = $value['provider'];
$model_id = $value['model'];
$config = $value['config'];
```

Full migration examples and usage documentation are available in `docs/developers/ai_provider_configuration_element.md`.

## Timeline

- Opened: November 5, 2025
- Committed: February 16, 2026 (3 months later)

## Collaboration

Abhisekmazumdar built the core form element implementation over multiple iterations, addressing feedback on AJAX behavior, configuration field persistence, and value handling. Marcus Johansson provided thorough code review across many rounds, catching edge cases with default provider selection, configuration field visibility, and pseudo operation type handling. He also created the video demonstration and pushed for proper documentation.

Jibran provided detailed inline code review that improved code quality. Breidert functionally tested the element using custom test code, then implemented the `#inline_description` feature based on UX feedback, using Claude to accelerate the change while carefully reviewing the output. Emma horrell and angela saldaña provided UX review on the video demonstration, suggesting the inline description placement to improve user comprehension. Ferran_bosch reviewed the overall UX flow and confirmed the design decisions made sense.

## Lessons learned

- When building reusable form elements that integrate with external services, provide configuration flags to toggle advanced features (like provider-specific settings) rather than building multiple specialized elements. This allows the same element to serve both simple and complex use cases. *(via marcus_johansson, abhisekmazumdar)*
- When creating form elements with AJAX-driven dependent fields, avoid relying solely on the 'access' property to show/hide fields after callbacks. Instead, explicitly manage field visibility state through the rebuild to ensure dependent fields properly respond to all selection changes. *(via abhisekmazumdar)*
- When form elements display dynamic configuration options loaded via AJAX, previous field values from earlier selections can persist in the form state. Clear or rebuild dependent sections completely when the parent selection changes to prevent stale fields from appearing. *(via marcus_johansson, abhisekmazumdar)*
- When creating reusable components not yet integrated into the codebase, provide concrete test implementations in the issue documentation. This enables reviewers to functionally validate the component without needing to guess integration patterns. *(via abhisekmazumdar, breidert)*

---

*This summary is AI-generated and may contain errors. Check the [original issue on Drupal.org](https://www.drupal.org/node/3556181) for the full picture. For more digests, see [Drupal Digests](https://github.com/dbuytaert/drupal-digests/).*
